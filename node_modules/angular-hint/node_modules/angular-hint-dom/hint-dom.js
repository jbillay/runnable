'use strict';

/**
* Create an interceptor that will log a message when use of a DOM API is detected
*/
var domInterceptor = require('dom-interceptor');
domInterceptor.enableLineNumbers(3);
var hintLog = angular.hint = require('angular-hint-log');
var INTERCEPTOR_FUNCTION = function(message) {
  hintLog.logMessage(message);
};

/**
* Decorates $controller with a patching function to
* throw an error if DOM APIs are manipulated from
* within an Angular controller
*/
angular.module('ngHintDom', []).
  config(function ($provide) {
    $provide.decorator('$controller', function($delegate, $injector) {

      var patchedServices = {};

      return function(ctrl, locals) {

        if(typeof ctrl === 'string') {
          ctrl = nameToConstructorMappings[ctrl];
        }

        var dependencies = $injector.annotate(ctrl);

        // patch methods on $scope
        locals = locals || {};
        dependencies.forEach(function (dep) {
          if (typeof dep === 'string' && !locals[dep]) {
            locals[dep] = patchedServices[dep] ||
              (patchedServices[dep] = patchService($injector.get('$timeout')));
          }
        });

        function disallowedContext(fn) {
          return function () {
            domInterceptor.addManipulationListener(INTERCEPTOR_FUNCTION);
            var ret = fn.apply(this, arguments);
            domInterceptor.removeManipulationListener();
            return ret;
          };
        }

        function patchArguments (fn) {
          return function () {
            for (var i = 0, ii = arguments.length; i < ii; i++) {
              if (typeof arguments[i] === 'function') {
                arguments[i] = disallowedContext(arguments[i]);
              }
            }
            return fn.apply(this, arguments);
          };
        }

        function patchService (obj) {
          if (typeof obj === 'function') {
            return patchArguments(obj);
          } else if (typeof obj === 'object') {
            return Object.keys(obj).reduce(function (obj, prop) {
              return obj[prop] = patchService(obj[prop]), obj;
            }, obj);
          }
          return obj;
        }

        //Detect manipulation of DOM APIs from within the body of the controller
        domInterceptor.addManipulationListener(INTERCEPTOR_FUNCTION);
        var ctrlInstance = $delegate.apply(this, [ctrl, locals]);
        domInterceptor.removeManipulationListener();

        //Detect manipulation of DOM APIs from properties on the controller
        Object.keys(ctrlInstance).forEach(function (prop) {
          if (prop[0] !== '$' && typeof ctrlInstance[prop] === 'function') {
            ctrlInstance[prop] = disallowedContext(ctrlInstance[prop]);
          }
        });

        //Detect manipulation of DOM APIs from functions defined inside the controller
        if(locals.$scope) {
          Object.keys(locals.$scope).forEach(function (prop) {
            if([prop][0] !== '$' && typeof locals.$scope[prop] === 'function') {
              locals.$scope[prop] = disallowedContext(locals.$scope[prop]);
            }
          });
        }

        return ctrlInstance;
      };
    });
  });

/**
* Keep a record of 'ControllerName': Controller pairs
* so that a controller can be retrieved via its name
*/
var nameToConstructorMappings = {};
var originalAngularModule = angular.module;
angular.module = function() {
  var module = originalAngularModule.apply(this, arguments);
  var originalController = module.controller;
  module.controller = function(controllerName, controllerConstructor) {
    nameToConstructorMappings[controllerName] = controllerConstructor;
    return originalController.apply(this, arguments);
  };
  return module;
};
